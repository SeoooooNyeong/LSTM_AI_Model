# -*- coding: utf-8 -*-
"""train.py

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1yH2IXSLmyWMaP9CdZGv71UQh9Fy9f933
"""

import torch
import torch.nn as nn
import torch.optim as optim
import pandas as pd
from sklearn.preprocessing import MinMaxScaler
from sklearn.metrics import mean_absolute_error
import numpy as np

# 데이터 로드
train_data = pd.read_csv('./drive/MyDrive/trtr.csv')
test_data = pd.read_csv('./drive/MyDrive/tsts.csv')

train_data['date'] = pd.to_datetime(train_data['date'])
train_data['hour'] = train_data['date'].dt.hour

test_data['date'] = pd.to_datetime(test_data['date'])
test_data['hour'] = test_data['date'].dt.hour

train_data.drop(columns=['date'], inplace=True)
test_data.drop(columns=['date'], inplace=True)

def fourier_features(index, freq, order):
    time = np.arange(len(index), dtype=np.float32)
    k = 2 * np.pi * (1 / freq) * time
    features = {}
    for i in range(1, order + 1):
        features.update({
            f"cos_{freq}_{i}": np.cos(i * k),
        })
    return pd.DataFrame(features, index=index)

train_data['cos_24_1'] = np.cos(2 * np.pi * train_data['hour']/23.0)
fourier_features(train_data['hour'], 24, 1)

def fourier_features(index, freq, order):
    time = np.arange(len(index), dtype=np.float32)
    k = 2 * np.pi * (1 / freq) * time
    features = {}
    for i in range(1, order + 1):
        features.update({
            f"cos_{freq}_{i}": np.cos(i * k),
        })
    return pd.DataFrame(features, index=index)

test_data['cos_24_1'] = np.cos(2 * np.pi * test_data['hour']/23.0)
fourier_features(test_data['hour'], 24, 1)

train_data = train_data[['temperature','humidity','amount','cos_24_1']]
test_data = test_data[['temperature','humidity','amount','cos_24_1']]

# 결측치 대체
train_data = train_data.fillna(method='ffill')
test_data = test_data.fillna(method='ffill')

# 이상치이전 값으로 대체
train_data['amount'] = train_data['amount'].where(train_data['amount'] <= 10000, other=train_data['amount'].shift())
test_data['amount'] = test_data['amount'].where(test_data['amount'] <= 10000, other=test_data['amount'].shift())


# 입력 변수 추출
train_features = train_data[['temperature', 'humidity','cos_24_1']].values
test_features = test_data[['temperature', 'humidity','cos_24_1']].values

# 출력 변수 추출
train_target = train_data['amount'].values
test_target = test_data['amount'].values

# 데이터 정규화
scaler = MinMaxScaler(feature_range=(-1, 1))
train_features_normalized = scaler.fit_transform(train_features)
test_features_normalized = scaler.transform(test_features)
train_target_normalized = scaler.fit_transform(train_target.reshape(-1, 1))
test_target_normalized = scaler.transform(test_target.reshape(-1, 1))

# 시퀀스 생성
def create_sequences(features, target, seq_length):
    xs = []
    ys = []
    for i in range(len(features) - seq_length):
        x = features[i:i + seq_length]
        y = target[i + seq_length]
        xs.append(x)
        ys.append(y)
    return torch.tensor(np.array(xs)).float(), torch.tensor(np.array(ys)).float()

# 하이퍼파라미터 설정
seq_length = 7
input_dim = train_features.shape[1]
hidden_dim = 256
output_dim = 1
num_layers = 2
learning_rate = 0.01
num_epochs = 150

# 시퀀스 생성
train_X, train_y = create_sequences(train_features_normalized, train_target_normalized, seq_length)
test_X, test_y = create_sequences(test_features_normalized, test_target_normalized, seq_length)

# LSTM 모델 정의
class LSTMModel(nn.Module):
    def __init__(self, input_dim, hidden_dim, output_dim, num_layers):
        super(LSTMModel, self).__init__()
        self.hidden_dim = hidden_dim
        self.num_layers = num_layers
        self.lstm = nn.LSTM(input_dim, hidden_dim, num_layers, batch_first=True)
        self.fc = nn.Linear(hidden_dim, output_dim)
        
    def forward(self, x):
        h0 = torch.zeros(self.num_layers, x.size(0), self.hidden_dim).to(device)
        c0 = torch.zeros(self.num_layers, x.size(0), self.hidden_dim).to(device)
        out, _ = self.lstm(x, (h0, c0))
        out = self.fc(out[:, -1, :])
        return out

# GPU 사용 가능 여부 확인
device = torch.device('cuda' if torch.cuda.is_available() else 'cpu')

# 모델 초기화 및 GPU로 이동
model = LSTMModel(input_dim, hidden_dim, output_dim, num_layers).to(device)

# 손실 함수 및 최적화 알고리즘 정의
criterion = nn.L1Loss()
optimizer = optim.Adam(model.parameters(), lr=learning_rate)

# 학습
model.train()
for epoch in range(num_epochs):
    inputs, targets = train_X.to(device), train_y.to(device)
    
    optimizer.zero_grad()
    outputs = model(inputs)
    loss = criterion(outputs, targets)
    loss.backward()
    optimizer.step()
    
    print(f'Epoch {epoch+1}/{num_epochs}, Loss: {loss.item()}')